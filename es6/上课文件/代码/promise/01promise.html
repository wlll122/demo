<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title></title>
	</head>
	<body>
		<script>
 //  什么是promise？
	// 从语法上来说:promise是一个构造函数,
	// 从功能上说,promise对象用来封装一个异步操作并可以获取其结果
	//1.创建一个promise对象
	/**
	var p=new Promise(function(resolve,reject){
		console.log(11);
		resolve('成功的回到函数！')
	})
	
	p.then(function(res){
		console.log(res)
	},function(err){
		console.log(err)
	})
	
	**/
	
	/**
  var p=new Promise((resolve,reject)=>{
	  var num=Math.ceil(Math.random()*10);
	  if(num<5){
		  resolve('成功的数据');
	  }else{
		  reject('失败的数据'+num);
	  }
  })	
	
	p.then((res)=>{
		console.log(res);
	},(err)=>{
		console.log(err);
	})
	
	**/
	
	var p=new Promise((resolve,reject)=>{
				
		setTimeout(()=>{
		   var d=Date.now();
			if(d%2==0){
				resolve('成功的数据'+d);
			}else{
				reject('失败的数据'+d)
			}
		},1000)
	})
	
	//console.log(Date.now());
	
	p.then((res)=>{
		console.log(res);
	}).catch(err=>{
		console.log(err);
	})
	
	/**		
	2.为什么要用Promise
		1.指定回调函数的方式更加灵活
			旧的:必须要在启动异步任务前指定,
			promise:启动异步任务=>返回promise对象=>给promise对象绑定回调函数(甚至可以在异步任务结束之后执行)
	2.支持链式调用,可以解决回调地狱问题
	    什么是回调地狱？回调函数嵌套调用,外部回调函数异步执行的结果是嵌套的回调函数执行的条件
	回调地狱的缺点？不便于阅读 / 不便于异常处理
	
	解决方案？Promise链式调用
	
	终极解决方案？async/await 
	**/
   
   //2.1回调地狱
      dosomething(function(result){
		  dosomethingelse(result,function(reResult){
			  dothirdthing(reResult,function(finalResult){
				  console.log(finalResult)
			  },falilure)
		  },falilure)
		  
	  },failure)
 
  
  
  
  
  
   
   //2.2使用promise的链式调用解决回调地狱
	 dosomething().then(function(result){
		 return  dosomethingelse(result)
	 })
	 .then(function(reResult){
		 return dothirdthing(reResult)
	 })
	 .then(function(finalResult){
		 console.log(finalResult)
	 }).catch(failure)
	 
	
	
	
	
		</script>
	</body>
</html>
